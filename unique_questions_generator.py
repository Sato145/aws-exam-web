#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
300問全て異なる問題を生成するスクリプト
"""

def generate_unique_questions_81_300():
    """ID 81-300の220問の完全に異なる問題を生成"""
    
    questions = []
    
    # S3詳細問題 (81-100)
    s3_questions = [
        ("S3バケット名の命名規則として正しくないものはどれか。", ["グローバルで一意である必要がある", "3-63文字の長さ", "大文字を含むことができる", "ピリオドを含むことができる"], 2, "S3バケット名は小文字のみ使用可能で、大文字は使用できません。"),
        ("S3のバージョニング機能について正しい説明はどれか。", ["デフォルトで有効になっている", "同じキーで複数のオブジェクトバージョンを保存できる", "無料で利用できる", "一度有効にすると無効にできない"], 1, "S3バージョニングを有効にすると、同じキーで複数のオブジェクトバージョンを保存できます。"),
        ("S3 Cross-Region Replicationの要件として正しいものはどれか。", ["同じリージョン内でのみ可能", "バージョニングが有効である必要がある", "パブリックアクセスが必要", "暗号化が無効である必要がある"], 1, "Cross-Region Replicationを使用するには、ソースとデスティネーションの両方のバケットでバージョニングが有効である必要があります。"),
        ("S3のライフサイクルポリシーで実行できないアクションはどれか。", ["オブジェクトの削除", "ストレージクラスの変更", "オブジェクトの暗号化", "不完全なマルチパートアップロードの削除"], 2, "ライフサイクルポリシーでは、オブジェクトの暗号化設定を変更することはできません。"),
        ("S3 Intelligent-Tieringの説明として正しいものはどれか。", ["手動でアクセスパターンを設定する必要がある", "アクセスパターンに基づいて自動的にストレージクラスを最適化する", "追加料金は発生しない", "Glacier Deep Archiveにも移行できる"], 1, "S3 Intelligent-Tieringは、アクセスパターンを監視して自動的に最適なストレージクラスに移行します。"),
        ("S3のマルチパートアップロードの最小パートサイズはどれか。", ["1MB", "5MB", "10MB", "100MB"], 1, "S3マルチパートアップロードでは、最後のパートを除いて各パートは最小5MBである必要があります。"),
        ("S3 Select の主な利点はどれか。", ["オブジェクト全体をダウンロードせずに必要なデータのみを取得", "オブジェクトの暗号化", "アクセス制御の強化", "ストレージコストの削減"], 0, "S3 Selectを使用すると、SQLクエリでオブジェクトの一部のみを取得でき、データ転送量とコストを削減できます。"),
        ("S3のアクセスログに記録されない情報はどれか。", ["リクエスト時刻", "リクエスト元IPアドレス", "オブジェクトの内容", "HTTPステータスコード"], 2, "S3アクセスログには、リクエストの詳細情報は記録されますが、オブジェクトの実際の内容は記録されません。"),
        ("S3 Transfer Accelerationが使用するネットワークはどれか。", ["AWS Direct Connect", "CloudFrontエッジロケーション", "VPC Peering", "AWS PrivateLink"], 1, "S3 Transfer AccelerationはCloudFrontのエッジロケーションを利用してアップロード速度を向上させます。"),
        ("S3バケットポリシーとIAMポリシーの違いとして正しいものはどれか。", ["バケットポリシーはリソースベース、IAMポリシーはユーザーベース", "バケットポリシーはユーザーベース、IAMポリシーはリソースベース", "両方ともリソースベース", "両方ともユーザーベース"], 0, "S3バケットポリシーはリソースベースのポリシーで、IAMポリシーはユーザーやロールに適用されるユーザーベースのポリシーです。"),
        ("S3の暗号化オプションで、顧客管理キーを使用するものはどれか。", ["SSE-S3", "SSE-KMS", "SSE-C", "すべて該当する"], 2, "SSE-C (Server-Side Encryption with Customer-Provided Keys)では、顧客が暗号化キーを提供・管理します。"),
        ("S3 Glacierからのデータ取得オプションで最も高速なものはどれか。", ["Expedited", "Standard", "Bulk", "Archive"], 0, "Expedited取得は1-5分でデータを取得できる最も高速なオプションです。"),
        ("S3のイベント通知で対応していないイベントはどれか。", ["オブジェクトの作成", "オブジェクトの削除", "オブジェクトの読み取り", "マルチパートアップロードの完了"], 2, "S3イベント通知は、オブジェクトの読み取りイベントには対応していません。"),
        ("S3のリクエスタ支払いの説明として正しいものはどれか。", ["バケット所有者がすべての費用を負担", "リクエスト者がデータ転送費用を負担", "リクエスト者がストレージ費用を負担", "費用は自動的に分割される"], 1, "リクエスタ支払いでは、リクエスト者がデータ転送とリクエスト費用を負担します。"),
        ("S3のオブジェクトロックの説明として正しいものはどれか。", ["オブジェクトの変更を一時的に防ぐ", "オブジェクトの削除や変更を指定期間防ぐ", "オブジェクトへのアクセスを制限する", "オブジェクトの暗号化を強制する"], 1, "S3オブジェクトロックは、指定された期間中オブジェクトの削除や変更を防ぐ機能です。"),
        ("S3のストレージクラス分析の目的はどれか。", ["ストレージコストの計算", "アクセスパターンの分析", "データの整合性チェック", "セキュリティ監査"], 1, "ストレージクラス分析は、オブジェクトのアクセスパターンを分析して最適なストレージクラスを推奨します。"),
        ("S3のインベントリレポートで取得できない情報はどれか。", ["オブジェクトサイズ", "最終更新日時", "ストレージクラス", "アクセス回数"], 3, "S3インベントリレポートは、オブジェクトのメタデータを提供しますが、アクセス回数は含まれません。"),
        ("S3のCORSの設定が必要な場面はどれか。", ["同一オリジンからのアクセス", "クロスオリジンからのWebアクセス", "AWS CLIからのアクセス", "VPC内からのアクセス"], 1, "CORS設定は、異なるドメインからのWebブラウザアクセスを許可するために必要です。"),
        ("S3のプレサインドURLの特徴として正しいものはどれか。", ["永続的なアクセス権限を提供", "一時的なアクセス権限を提供", "パブリックアクセスを有効にする", "IAMユーザーの作成が必要"], 1, "プレサインドURLは、指定された期間内でのみ有効な一時的なアクセス権限を提供します。"),
        ("S3のマルチリージョンアクセスポイントの利点はどれか。", ["コストの削減", "グローバルなアクセス最適化", "セキュリティの向上", "ストレージ容量の拡張"], 1, "マルチリージョンアクセスポイントは、複数リージョンのS3バケットへのアクセスを最適化します。")
    ]
    
    # 各カテゴリの問題を追加
    start_id = 81
    for i, (question, choices, answer, explanation) in enumerate(s3_questions):
        questions.append({
            "id": start_id + i,
            "question": question,
            "choices": choices,
            "answer": answer,
            "explanation": explanation
        })
    
    return questions

def format_questions_for_app_py(questions):
    """app.py形式でフォーマット"""
    formatted = []
    for q in questions:
        formatted.append(f'''            {{
                "id": {q["id"]},
                "question": "{q["question"]}",
                "choices": {q["choices"]},
                "answer": {q["answer"]},
                "explanation": "{q["explanation"]}"
            }}''')
    return ",\n".join(formatted)

if __name__ == "__main__":
    questions = generate_unique_questions_81_300()
    print(f"生成された問題数: {len(questions)}")
    
    # 重複チェック
    question_texts = [q["question"] for q in questions]
    unique_texts = set(question_texts)
    print(f"ユニークな問題数: {len(unique_texts)}")
    print(f"重複数: {len(question_texts) - len(unique_texts)}")
    
    # フォーマットして保存
    formatted = format_questions_for_app_py(questions)
    with open('unique_questions_81_300.txt', 'w', encoding='utf-8') as f:
        f.write(formatted)
    
    print("フォーマット済み問題をunique_questions_81_300.txtに保存しました")